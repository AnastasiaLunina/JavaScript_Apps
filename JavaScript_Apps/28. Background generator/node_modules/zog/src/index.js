import Debug from 'debug'
import chalk from 'chalk'
import {getCallerFile, getCallerFileAsync, makeIDELink} from 'live-caller'
import logCallsite from './log-callsite'
import {autobind} from 'core-decorators'
import emoji from 'node-emoji'
import tildify from 'tildify'
import detectNode from 'detect-node'

const Console = console

const debugCache = {}

// TODO(vjpr): Should be configurable.
// NOTE: We don't need to make a special ide link if using iTerm2.
const useIdeLink = false

function getLoggerName(callInfo) {
  const {path, line, col} = callInfo
  // TODO(vjpr): Make relative from source dir but remember its used client side too.
  // TODO(vjpr): Check if path is null.
  return path.split('/').slice(-2).join('/')
  //return path.relative(process.cwd(), path)
}

function getDebugModule(callInfo) {
  const {path, line, col} = callInfo
  const loggerName = getLoggerName(callInfo)
  if (!debugCache[path]) debugCache[path] = Debug(loggerName)
  return debugCache[path]
}

// Uncomment to track to spurious console.log calls.
//logCallsite.hookConsoleLog()

//const test = {
//  a: 1,
//  b: 2
//}
//
//function yo() {
//
//  }

@autobind
class Logger {

  _ns = '';

  // debug module doesn't work if its an empty string.
  constructor(ns = 'default') {
    this._ns = ns
    this.logger = Debug(ns)

    //this.logger.log = console.log.apply(console, arguments)
    //this.logger = console.log
  }

  ns(ns) {
    this._ns = ns
    return this
  }

  log(...args) {

    //const callInfo = callsite()
    //this.logger.apply(this.debugModule, args)
    Console.log(...args)

    // Print file location.
    if (global.__CLIENT__) {
      if (useIdeLink) {

        // Source maps not working with new Error().stack.
        // https://bugs.chromium.org/p/chromium/issues/detail?id=357958

        // Hangs browser.
        //getCallerFileAsync(1).then((callInfo) => {
        //  Console.log('  ' + chalk.gray(makeIDELink(callInfo)))
        //})

      }
    }
    // ---

    return this
  }

  // TODO(vjpr): With iTerm2, don't need to make hyperlink anymore.
  //
  // E.g.
  //
  // app/registry.js Generator cached hit for key: package-json!/Users/Vaughan/dev-live-test +0ms
  // app/registry.js   idea://open?file=/Users/Vaughan/dev-live/drum/lib/app/registry.js&line=229:24 +2ms
  //
  debug(...args) {

    // TODO(vjpr): We need to use a stacktrace-js source cache if we are to do this.
    //const useAsyncStackTrace = !detectNode
    const useAsyncStackTrace = false

    if (useAsyncStackTrace) {
      getCallerFileAsync(1).then((callInfo) => {
        run(callInfo)
      })
      return
    } else {
      // TODO(vjpr): This may slow things down a lot!
      //   And causing a max call stack exceeded...
      const callInfo = getCallerFile(1)
      return run(callInfo)
    }

    function run(callInfo) {

      const logger = getDebugModule(callInfo)
      logger.apply(logger, args)

      if (useIdeLink && callInfo) {
        logger.apply(logger, ['  ' + chalk.gray(makeIDELink(callInfo))])
      }

      return this

    }

  }

  error(...args) {
    Console.error(emoji.get(':no_entry_sign:') + chalk.red('  ERROR:', ...args))
    return this
  }

  warn(...args) {
    Console.warn(emoji.get(':warning:') + chalk.yellow('  WARNING:', ...args))
    return this
  }

  info(...args) {
    Console.log(chalk.cyan(...args))
    return this
  }

}

function printFileStr(file) {
  return chalk.dim(tildify(file))
}

// Legacy
// TODO: Maybe don't cache the logger so it creates an instance each time
//  and uses the callsite to get the name of the module.

////////////////////////////////////////////////////////////////////////////////
// Singleton API
////////////////////////////////////////////////////////////////////////////////

// TODO(vjpr): Include usage information from configurize.

const singleton = new Logger

export {Console}
export const info = singleton.info
export const log = singleton.log
export const debug = singleton.debug
export const warn = singleton.warn
export const error = singleton.error
export const time = console.time
export const timeEnd = console.timeEnd
export {default as xcolor} from 'xcolor'
export {default as xc} from 'xcolor'
export {default as c} from 'chalk'
export {default as line} from 'chalkline'
export {default as Debug} from 'debug'

export {singleton as logger}
export {Logger}

export default singleton

////////////////////////////////////////////////////////////////////////////////
