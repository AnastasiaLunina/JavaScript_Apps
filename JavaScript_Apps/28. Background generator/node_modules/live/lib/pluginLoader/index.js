'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PluginLoader = undefined;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _string = require('string');

var _string2 = _interopRequireDefault(_string);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _outlet = require('outlet');

var _eventemitter = require('eventemitter3');

var _eventemitter2 = _interopRequireDefault(_eventemitter);

var _locator = require('../locator');

var _locator2 = _interopRequireDefault(_locator);

var _liveServiceHub = require('live-service-hub');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('zog'),
    Debug = _require.Debug;

var debug = Debug('live:plugin-loader');


var useDynamicRequire = false;

// TODO(vjpr): Add flowtypes.

var PluginLoader = exports.PluginLoader = function () {
  function PluginLoader(container, serviceHub) {
    (0, _classCallCheck3.default)(this, PluginLoader);

    this.container = container;
    this.serviceHub = serviceHub;
    _lodash2.default.defaults(this.container, {
      vent: new _eventemitter2.default(),
      state: {}
    });
  }

  (0, _createClass3.default)(PluginLoader, [{
    key: 'loadPlugins',
    value: function loadPlugins() {
      var _this = this;

      var _getPluginFiles = this.getPluginFiles(this.container),
          files = _getPluginFiles.files,
          dynamicRequire = _getPluginFiles.dynamicRequire;

      (0, _lodash2.default)(files).each(function (f) {
        var rawModule = _this.requireModule(f, dynamicRequire);
        _this.register(rawModule, f);
      }).run

      // TODO: Files are two different things (webpack or node path). Change this.
      ();return files;
    }
  }, {
    key: 'register',
    value: function register(rawModule) {
      var fullPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var _getLiveModule = this.getLiveModule(rawModule

      // Invalid module.
      ),
          module = _getLiveModule.module,
          registerFn = _getLiveModule.registerFn;

      if (!module) {
        var text = fullPath ? fullPath : '\n' + rawModule.toString();
        this.container.vent.emit('invalid-module', text);
        return;
      }

      // Set module name, if it doesn't exist.
      if (!module.$name) module.$name = this.getModuleName(fullPath, module);

      module.$fullPath = fullPath;
      if (fullPath) module.$projectRelativePath = _path2.default.relative(process.cwd(), fullPath);

      this.printPlugin(fullPath, module.$name

      // Extract these out of the plugin loader.

      );this.registerLiveModuleConfig({ module: module }

      // TODO(vjpr): Validate json schema.

      );this.registerLiveModule({ module: module, registerFn: registerFn });

      this.registerLiveModuleServices({ module: module });
    }

    // TODO(vjpr): Over-engineering. Abstract this away.
    ///
    /// Allows us to support a variety of Live module formats.
    ///
    /// We need to do two things with modules.
    /// - Read meta-data from the module.
    /// - Pass the Live application instance to a registration function.
    ///
    /// @param {} module - the result of a `require(...)` call.
    /// @returns {object} obj
    /// @returns {object} obj.module - the instantiated Live module.
    /// @returns {Function} obj.registerFn - function which is passed the Live application instance.
    ///

  }, {
    key: 'getLiveModule',
    value: function getLiveModule(rawModule) {

      // Plain object.
      if (rawModule.register) return { module: rawModule, registerFn: rawModule.register

        // Class.
      };if (rawModule.prototype) {
        // We don't require register method anymore.
        //if (!rawModule.prototype.register) return {module: null}
        var liveModule = new rawModule();
        return { module: liveModule, registerFn: liveModule.register };
      }

      // Function.
      if (_lodash2.default.isFunction(rawModule)) {
        return { module: rawModule, registerFn: rawModule };
      }

      return { module: null };
    }
  }, {
    key: 'getModuleName',
    value: function getModuleName(fullPath, module) {
      if (module.name) return module.name;
      if (fullPath) {
        //if (!isNode) return null
        return _path2.default.basename(_path2.default.dirname(fullPath) // TODO: Double check this works for webpack - context.keys()! Maybe we can get more info from the context.)
        );
      } else {
        return null;
      }
    }

    //
    // Register a module.
    //
    // Calls the register method on a module.
    //

  }, {
    key: 'registerLiveModule',
    value: function registerLiveModule(_ref) {
      var module = _ref.module,
          registerFn = _ref.registerFn;


      var moduleName = module.$name;

      // Create a namespace for each module in our `state` variable in our container.

      this.createContainerStateNamespace(moduleName

      // Register plugin.

      // TODO(vjpr): Should we depend on Outlet here?
      );var live = new _outlet.Outlet(this.container);
      live.moduleName = moduleName;
      registerFn && registerFn.call(module, live);
    }

    // Register services using LiveServiceHub.

  }, {
    key: 'registerLiveModuleServices',
    value: function registerLiveModuleServices(_ref2) {
      var module = _ref2.module;
      var serviceHub = this.serviceHub;
      var services = module.services;

      var modulePath = module.$projectRelativePath;
      (0, _liveServiceHub.registerServicesFromDict)({ serviceHub: serviceHub, services: services, module: module, modulePath: modulePath });
    }
  }, {
    key: 'registerLiveModuleConfig',
    value: function registerLiveModuleConfig(_ref3) {
      var module = _ref3.module;


      // When this is run, configurize will have already initialized.

      if (!module.config) return;

      if (global.__CLIENT__) {
        // NOTE: This require request must match name set in webpack config alias.
        require('configurize.browser.js').config.setDefaults(module.$name, module.config);
      } else {
        require('configurize').config.setDefaults(module.$name, module.config);
      }
    }
  }, {
    key: 'createContainerStateNamespace',
    value: function createContainerStateNamespace(moduleName) {
      if (moduleName) {
        var ns = (0, _string2.default)(moduleName).camelize
        // Multiple modules maybe be registered under one namespace when using `live.shared.js`.
        ();if (!this.container.state[ns]) this.container.state[ns] = {};
      } else {
        throw new Error('You must provide a name for your plugin. Add a `$name` property to the live file.');
      }
    }
  }, {
    key: 'requireModule',
    value: function requireModule(f) {
      if (global.__CLIENT__) {
        // Plugins will already be setup on window object.
        debug('Requiring module:', f);
        return window.livePlugins[f];
      } else {
        return require('./node')(f);
      }
    }
  }, {
    key: 'getPluginFiles',
    value: function getPluginFiles() {
      var files = void 0;
      if (global.__CLIENT__) {
        // NOTE: This file is generated on webpack build.
        //const livePlugins = require('generated/live-browser-plugin-requires-generated')
        var livePlugins = window.livePlugins; // Alternative.
        debug('Found Live Plugins', livePlugins);
        files = (0, _keys2.default)(livePlugins);
      } else {
        files = (0, _locator2.default)();
      }
      return { files: files };
    }
  }, {
    key: 'getRawModules',
    value: function getRawModules(files) {}

    // TODO(vjpr): Add an explanation of how this works. Reading from the top should
    // explain everything. Who calls what and from where.

  }, {
    key: 'printPlugin',
    value: function printPlugin(fullPath, moduleName) {
      var relPath = fullPath ? _path2.default.relative(process.cwd(), fullPath) : '';
      this.container.vent.emit('register-plugin', { moduleName: moduleName, relPath: relPath });
    }
  }]);
  return PluginLoader;
}();
//# sourceMappingURL=index.js.map
