import locator from 'live-locator'
import path from 'path'
import chalk from 'chalk'
import s from 'string'
import _ from 'lodash'
import Dict from 'core-js/library/fn/dict'

function printPlugin(f, moduleName) {
  const relPath = path.relative(process.cwd(), f)
  console.log(`Registering plugin ${chalk.bold(moduleName)} ${chalk.gray(relPath)}`)
}

const container = {}
const serviceIdToModule = {}

module.exports = function(app) {

  const files = locator()

  //
  // Get providers
  //

  for (let f of files) {

    const {module, moduleName} = getModule(f)

    const provides = module.$provides || null

    // Get provider map.
    if (module.$provides) {
      for (let [k, v] of Dict.entries(module.$provides)) {
        serviceIdToModule[k] = serviceIdToModule[k] || []
        serviceIdToModule[k].push({moduleName, module})
      }
    }

  }

  //
  // Create tasks
  //

  for (let f of files) {

    const {module, moduleName} = getModule(f)

    // Check if the module does anything.
    // TODO: Make a better check. We need to take into account
    // the different types of module defs (plain object vs. class).
    //if (!module.register && !module.init) {
    //  continue
    //}

    printPlugin(f, moduleName)

    // Register plugin.

    if (module.register) {
      module.register(app)
    }

    // Create init task for module.

    const dependencies = module.$require || module.$consumes || module.$args || []

    // Create a namespace for each module in our singleton.

    const camelizedModuleName = s(moduleName).camelize()
    app[camelizedModuleName] = {}

    // Convert service dependencies. E.g. `svc!live-routes:routes`.

    let realDeps = dependencies.slice(0)

    const serviceRequires = dependencies.reduce((acc, dep) => {
      const parts = s(dep).split('!')
      if (parts.length <= 1) return acc
      const [requirePlugin, serviceName] = parts

      // Remove services from dependencies.
      // TODO: Move outside this reduce into its own loop.
      _(realDeps).remove(xÂ => x === dep).run()

      // This module should depend on all modules which provide `serviceName`.
      if (!serviceIdToModule[serviceName]) return acc
      const serviceNames = serviceIdToModule[serviceName].map((v) =>
        v.moduleName
      )
      return acc.concat(serviceNames)
    }, [])

    realDeps.push(...serviceRequires)

    // Init each module.

    app.task(moduleName, {after: realDeps, namespace: false, customLink: f, desc: module.$desc}, async function() {
      // TODO: Pass dependencies along.

      let args = []

      for (let dep of dependencies) {

        const parts = s(dep).split('!')
        if (parts.length >= 1) {
          const [requirePlugin, serviceName] = parts
          // Service dep.
          const serviceImplementors = serviceIdToModule[serviceName]
          const fn = async function(...args) {
            const results = []
            for (let {module, moduleName} of serviceImplementors) {
              const provider = container[moduleName][module.$provides[serviceName]]
              const result = await provider(...args)
              results.push(result)
            }
            return results
          }
          args.push(fn)
        } else {
          // Non-service dep.
          args.push(container[dep])
        }

      }

      if (module.init) {
        const result = await module.init(app, ...args)
        container[moduleName] = result
      }
    })

  }

  return files

}

// TODO: Support class, static class members/plain object/exports.
const getModule = function(f) {

  // TODO: Maybe we want to support custom naming in the future, or using file names.
  const moduleName = path.basename(path.dirname(f))

  let module = require(f)

  // TODO: Use a better check for plain object.
  if (module.$require) return module

  if (_.isFunction(module)) {
    module = new module
  }

  return {module, moduleName}

}
