# Live Framework

## TODO

 * [] Remove style.less
 * [] Remove nodemon.json - make sure babel caching still works after doing this by deleting `tmp/`
 * [] bootstrap.config.js - move
 * [] Using `live-config` from the browser
 * [] Define plugins aren't working
 * [] Move ./assets dir
 * [] Allow return values from live-callbacks. This can be used for prop or instance var dep injection.
      We have to think about how this will work with `app.fire` namespacing.
 * [] live.shared.js - This file is included in the browser and webpack.
 * [] live-plugin=loader and live-config require.context to support moduleDirectories.
      Try using ContextReplacementPlugin - https://github.com/webpack/webpack/issues/118
 * [] The entire Live framework should use peer dependencies to allow easy hacking.

## Philosophy

At each level compatibility grows.

- Start with the main concepts.
- Then show a sample implementation.
- Then show the Live implementation.
 
## Node/Browser code sharing plugins

http://stackoverflow.com/questions/31724950/with-webpack-can-i-put-node-js-and-browser-code-in-the-same-file-but-prevent-t/31725085?noredirect=1#comment51387567_31725085

Because we use Webpack contexts, we use a regex to locate plugins.
Otherwise we would include all the server `live.js` files and all their code,
but we could wrap everything in flags and use the DefinePlugin...

Imports: But then we would have to make sure imports are not at the top level too. There
would be lots of changes.

Build speed: And would this slow down the build if we have to scan the files upfront?

Security: If everything uses `live-config` for config, there should be a problem with db passwords, etc. leaking out.  

## Dependencies
 
I want it to be as easy as possible to monkey patch modules.

Huge problem with this is nested dependencies. If you depend on something that
depends on something else, then it becomes very difficult to modify that something else.

The solution is to enforce peer dependencies for all Live related modules.

CON: `npm i` wont work as expected, as manual calls to install all the peer dependencies will be neccessary.

CON: Difficult if two modules use different versions of something. But if it's only Live modules we can take care of that.

PRO: To modify something simply copy clone it into the `patched_modules` directory and `npm link`.

Maybe we could encourage a private module workflow?

---

Framework code should go in the `live-core` module. Everything else is decoupled.

If you place a dependency in the top-level and npm install it will just use that one. So this workflow us fine.
Just need a faster way to `npm i`. Maybe something to delete all `foo/node_modules` directories recursively, then re-install.
Yep that's it! Then alias the module to use code from the `src` dir of most modules that do not require a build step. 

## Tag

A fast barebones hackable framework built for ES7.
