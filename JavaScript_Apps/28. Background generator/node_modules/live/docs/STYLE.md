See https://github.com/airbnb/javascript

# Imports

If there are lots of imports separate them into:

- vendor - E.g. `lodash`
- modules - Module search directories, such as `app-client`
  - some modules may become their own npm modules. we should only include modules here that won't be.
- relative - Relative requires, such as `./foo`
- dynamic - Required lower down, and not immediately.
- styles - `import index.less`

Also separate from code with dividing line.

// NOTE(vjpr): Not sure about this one...take it case by case.
NOTE: All async deferred `require` calls should be wrapped in a func and
placed at the top so its easy to see where things are required. See 'dynamic' below.

Optionally wrap in region for IntelliJ code folding if there's lots. 

```
...
```

E.g.

```
// Vendor
import _ from 'lodash'

// Modules
import client from 'app-client'

// Relative
import foo from './foo'

// Dynamic - not sure about this. Its a tradeoff.
const foo = () => require('./foo')

// Styles
import './index.less'

## Relative Imports

Don’t relative reference up. You won’t see it when it moves!

```
// Assume:-
// app-foo/bar/bar.js
// app-foo/baz/baz.js

// Bad
require('../bar')

// Good
require('app-foo/bar/bar.js')
```

////////////////////////////////////////////////////////////////////////////////

export class Foo { ... }

```

# Comments

## General

Always finish comments on their own line with full stop.
For headings don't worry about it.

```
// Good.

// Bad
```

## Dividing line

```
////////////////////////////////////////////////////////////////////////////////
```

## Headings

Use headings if it makes the code easier to read.

```
////////////////////////////////////////////////////////////////////////////////
// Heading 1
////////////////////////////////////////////////////////////////////////////////
```

## Dividers

Use half width dividers inside functions, if the code is quite complex.

```
switch (foo) {

////////////////////////////////////////

case 1: {

}

////////////////////////////////////////

case 2: {

}

////////////////////////////////////////

}

```

## TODOS

Include username.

`TODO(vjpr): xxx`
`DEBUG(vjpr): xxx`
`IMPORTANT(vjpr): xxx`
`NOTE(vjpr): xxx`

# Exports 

vjpr: I am leaning towards always exporting classes as keys not default, because it
ensure that same name is used everywhere which will make debugging easier.

If you need to rename it you can be explicit like `import Map as LeafletMap from ./Map`.

Also, I think Typescript encourages this approach.

NOTE: `export class` makes it more verbose when using Webpack's async loading with `require.ensure`.

```
// Bad
export default class Foo { ... } 

// Good
export class Foo { ... } 
```

## Modules

Have an `index.js` file in every module which exports other files. 
A React component's file should be named exactly the same as the component.

# Dictionarys

Always use trailing commas.

```
// Bad
const initialState = {
  step: 0
}

// Good
const initialState = {
  step: 0,
}
```

# Components

Always wrap JSX in parens (`()`) when returning in render.

# Functions

For functions there are 3 ways.

```
const fn = () => {}

const fn = async () => {}

const fn = function() {}

const fn = function fn() {}

function fn() {}
```

For top-level functions we prefer:

```
function fn() {}
```

Why?

- this is the same syntax used to define class methods so if we need to place 
  it in a class we only have to delete the `function` keyword.
- the name of the function is visible in the stack trace.

