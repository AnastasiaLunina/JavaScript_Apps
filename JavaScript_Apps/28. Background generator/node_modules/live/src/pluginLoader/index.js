const {Debug} = require('zog')
const debug = Debug('live:plugin-loader')
import path from 'path'
import chalk from 'chalk'
import s from 'string'
import _ from 'lodash'
import {Outlet} from 'outlet'
import EventEmitter from 'eventemitter3'
import locator from '../locator'
import {registerServicesFromDict} from 'live-service-hub'

const useDynamicRequire = false

// TODO(vjpr): Add flowtypes.
export class PluginLoader {

  constructor(container, serviceHub) {
    this.container = container
    this.serviceHub = serviceHub
    _.defaults(this.container, {
      vent: new EventEmitter,
      state: {},
    })
  }

  loadPlugins() {

    let {files, dynamicRequire} = this.getPluginFiles(this.container)

    _(files).each((f) => {
      const rawModule = this.requireModule(f, dynamicRequire)
      this.register(rawModule, f)
    }).run()

    // TODO: Files are two different things (webpack or node path). Change this.
    return files

  }

  register(rawModule, fullPath = null) {

    const {module, registerFn} = this.getLiveModule(rawModule)

    // Invalid module.
    if (!module) {
      const text = (fullPath ? fullPath : '\n' + rawModule.toString())
      this.container.vent.emit('invalid-module', text)
      return
    }

    // Set module name, if it doesn't exist.
    if (!module.$name) module.$name = this.getModuleName(fullPath, module)

    module.$fullPath = fullPath
    if (fullPath) module.$projectRelativePath = path.relative(process.cwd(), fullPath)

    this.printPlugin(fullPath, module.$name)

    // Extract these out of the plugin loader.

    this.registerLiveModuleConfig({module})

    // TODO(vjpr): Validate json schema.

    this.registerLiveModule({module, registerFn})

    this.registerLiveModuleServices({module})

  }

  // TODO(vjpr): Over-engineering. Abstract this away.
  ///
  /// Allows us to support a variety of Live module formats.
  ///
  /// We need to do two things with modules.
  /// - Read meta-data from the module.
  /// - Pass the Live application instance to a registration function.
  ///
  /// @param {} module - the result of a `require(...)` call.
  /// @returns {object} obj
  /// @returns {object} obj.module - the instantiated Live module.
  /// @returns {Function} obj.registerFn - function which is passed the Live application instance.
  ///
  getLiveModule(rawModule) {

    // Plain object.
    if (rawModule.register) return {module: rawModule, registerFn: rawModule.register}

    // Class.
    if (rawModule.prototype) {
      // We don't require register method anymore.
      //if (!rawModule.prototype.register) return {module: null}
      const liveModule = new rawModule
      return {module: liveModule, registerFn: liveModule.register}
    }

    // Function.
    if (_.isFunction(rawModule)) {
      return {module: rawModule, registerFn: rawModule}
    }

    return {module: null}

  }

  getModuleName(fullPath, module) {
    if (module.name) return module.name
    if (fullPath) {
      //if (!isNode) return null
      return path.basename(path.dirname(fullPath)) // TODO: Double check this works for webpack - context.keys()! Maybe we can get more info from the context.)
    } else {
      return null
    }
  }

  //
  // Register a module.
  //
  // Calls the register method on a module.
  //
  registerLiveModule({module, registerFn}) {

    const moduleName = module.$name

    // Create a namespace for each module in our `state` variable in our container.

    this.createContainerStateNamespace(moduleName)

    // Register plugin.

    // TODO(vjpr): Should we depend on Outlet here?
    const live = new Outlet(this.container)
    live.moduleName = moduleName
    registerFn && registerFn.call(module, live)

  }

  // Register services using LiveServiceHub.
  registerLiveModuleServices({module}) {
    const {serviceHub} = this
    const {services} = module
    const modulePath = module.$projectRelativePath
    registerServicesFromDict({serviceHub, services, module, modulePath})
  }

  registerLiveModuleConfig({module}) {

    // When this is run, configurize will have already initialized.

    if (!module.config) return

    if (global.__CLIENT__) {
      // NOTE: This require request must match name set in webpack config alias.
      require('configurize.browser.js').config.setDefaults(module.$name, module.config)
    } else {
      require('configurize').config.setDefaults(module.$name, module.config)
    }

  }

  createContainerStateNamespace(moduleName) {
    if (moduleName) {
      const ns = s(moduleName).camelize()
      // Multiple modules maybe be registered under one namespace when using `live.shared.js`.
      if (!this.container.state[ns]) this.container.state[ns] = {}
    } else {
      throw new Error('You must provide a name for your plugin. Add a `$name` property to the live file.')
    }
  }

  requireModule(f) {
    if (global.__CLIENT__) {
      // Plugins will already be setup on window object.
      debug('Requiring module:', f)
      return window.livePlugins[f]
    } else {
      return require('./node')(f)
    }
  }

  getPluginFiles() {
    let files
    if (global.__CLIENT__) {
      // NOTE: This file is generated on webpack build.
      //const livePlugins = require('generated/live-browser-plugin-requires-generated')
      const livePlugins = window.livePlugins // Alternative.
      debug('Found Live Plugins', livePlugins)
      files = Object.keys(livePlugins)
    } else {
      files = locator()
    }
    return {files}
  }

  getRawModules(files) {

  }

  // TODO(vjpr): Add an explanation of how this works. Reading from the top should
  // explain everything. Who calls what and from where.

  printPlugin(fullPath, moduleName) {
    const relPath = fullPath ? path.relative(process.cwd(), fullPath) : ''
    this.container.vent.emit('register-plugin', {moduleName, relPath})
  }

}
