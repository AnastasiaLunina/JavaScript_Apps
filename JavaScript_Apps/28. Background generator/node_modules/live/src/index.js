import setupLogging from './logging'
import {Live} from './live'
const locator = require('./locator')
import _ from 'lodash'

// Singleton app instance.
const live = new Live

// Setup basic logging.
setupLogging(live.container)

// Singleton app instance.
// E.g. When using `import {live} from 'live-app'` syntax to access the app.
main.live = live

main.Live = Live
main.Locator = locator.Locator

module.exports = main

////////////////////////////////////////////////////////////////////////////////

function getOpts(opts) {
  return _.defaults(opts, {
    beforeStart: (live) => {},
    locator: {},
    // TODO(vjpr): Look at how webpack does it.
    modules: {enabled: null, disabled: null},
  })
}

// opts.fn - an easy way to add hooks without creating a module.
function main(opts) {

  opts = getOpts(opts)

  // Locate and register plugins.

  if (!global.__CLIENT__) {
    locator(opts.locator).map(file => {
      if (shouldExcludeModule(file, opts.modules)) return
      const module = require(file)
      live.register(module, file)
    })
  } else {
    Object.keys(window.livePlugins).map(file => {
      if (shouldExcludeModule(file, opts.modules)) return
      const module = window.livePlugins[file]
      live.register(module, file)
    })
  }

  opts.beforeStart(live)

  // Start app.

  live.start().then(() => {
    // App has now started.
  })

  return live

}

// TODO(vjpr): Similar function can be found in `pluginLoader`. They should be in sync. However...rule of three refactoring!
function getModuleName(file) {
  const path = require('path')
  const moduleName = path.basename(path.dirname(file)) // TODO: Double check this works for webpack - context.keys()! Maybe we can get more info from the context.)
  return moduleName
}

function shouldExcludeModule(file, {enabled, disabled}) {
  const moduleName = getModuleName(file)
  if (enabled) {
    return !_.includes(enabled, moduleName)
  } else if (disabled) {
    return _.includes(disabled, moduleName)
  } else {
    return false
  }
}
