const debug = require('debug')('service-hub')
import {Disposable} from 'event-kit'
import Consumer from './consumer'
import Provider from './provider'

export default class ServiceHub {

  consumers:Array<any>;
  providers:Array<any>;

  constructor(opts = {}) {
    this.opts = opts
    this.consumers = []
    this.providers = []
    this.consumeQueue = []
  }

  // Public: Provide a service by invoking the callback of all current and future
  // consumers matching the given key path and version range.
  //
  // * `keyPath` A {String} of `.` separated keys indicating the services's
  //   location in the namespace of all services.
  // * `version` A {String} containing a [semantic version](http://semver.org/)
  //   for the service's API.
  // * `service` An object exposing the service API.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to remove the
  // provided service.
  provide(keyPath, version, service) {
    let servicesByVersion = {}
    if (service != null) {
      servicesByVersion[version] = service
    } else {
      servicesByVersion = version
    }

    let provider = new Provider(keyPath, servicesByVersion)
    this.providers.push(provider)

    for (const consumer of this.consumers) {
      if (!consumer.isDestroyed) {
        provider.provide(consumer)
      }
    }

    return new Disposable(() => {
      provider.destroy()
      let index = this.providers.indexOf(provider)
      return this.providers.splice(index, 1)
    })
  }

  // Public: Consume a service by invoking the given callback for all current
  // and future provided services matching the given key path and version range.
  //
  // * `keyPath` A {String} of `.` separated keys indicating the services's
  //   location in the namespace of all services.
  // * `versionRange` A {String} containing a [semantic version range](https://www.npmjs.org/doc/misc/semver.html)
  //   that any provided services for the given key path must satisfy.
  // * `callback` A {Function} to be called with current and future matching
  //   service objects.
  //
  // Returns a {Disposable} on which `.dispose()` can be called to remove the
  // consumer.
  consume(keyPath, versionRange, callback) {
    let consumer = new Consumer(keyPath, versionRange, callback)

    const consumeFn = () => {
      this.consumers.push(consumer)
      if (!consumer.isDestroyed) {
        for (const provider of this.providers) {
          if (!provider.isDestroyed) {
            provider.provide(consumer)
          }
        }
      }
    }

    if (!this.opts.runOnConsume) {
      // TODO(vjpr): Currently modules can only be wired up once.
      // TODO(vjpr): Use GroupedQueue.
      // TODO(vjpr): Allow promises for service providers.
      this.consumeQueue.push(consumeFn)
    } else {
      consumeFn()
      // TODO(vjpr): Using nextTick stopped working in Node 6.5 for some strange reason.
      //   This needs more thinking and a proper solution.
      //process.nextTick(() => {
      //  //this.run()
      //  consumeFn()
      //})
    }

    return new Disposable(() => {
      consumer.destroy()
      let index = this.consumers.indexOf(consumer)
      if (index >= 0) { return this.consumers.splice(index, 1) }
    })
  }

  run() {

    for (const fn of this.consumeQueue) {
      fn()
    }
    this.consumeQueue = []

  }

  // Public: Clear out all service consumers and providers, disposing of any
  // disposables returned by previous consumers.
  clear() {
    for (const provider of this.providers) {
      provider.destroy()
    }
    this.providers = []
    return this.consumers = []
  }
}
