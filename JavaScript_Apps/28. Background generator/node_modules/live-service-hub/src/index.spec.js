import {Disposable} from 'event-kit';
import ServiceHub from './service-hub';

describe("ServiceHub", function() {
  let hub = null;

  beforeEach(() => hub = new ServiceHub);

  let onNextTick = function(done, fn) {
    process.nextTick(fn)
    done()
    //waits(1);
    //return runs(fn);
  };

  describe("::consume(keyPath, versionString, callback)", function() {

    it("invokes the callback with each existing service that matches the key path and version range", function(done) {
      hub.provide("a", "1.0.0", {w: 1});
      hub.provide("b", "1.0.0", {x: 2});

      let services = [];
      hub.consume("a", "^1.0.0", service => services.push(service));

      hub.provide("a", "1.1.0", {y: 3});
      hub.provide("b", "1.2.0", {z: 4});

      expect(services).to.be.empty
      return onNextTick(done, () => expect(services).to.eql([{w: 1}, {y: 3}]));
    });

    it("invokes the callback with the newest version of a service provided in a given batch", function(done) {
      hub.provide("a", {
        "1.0.0": {w: 1},
        "1.1.0": {x: 2}
      });
      hub.provide("a",
        {"1.2.0": {y: 3}});
      hub.provide("b",
        {"1.0.0": {z: 4}});

      let services = [];
      hub.consume("a", "^1.0.0", service => services.push(service));

      expect(services).to.be.empty
      return onNextTick(done, () => expect(services).to.eql([{x: 2}, {y: 3}]));
    });

    it("invokes the callback when a new service is provided that matches the key path and version range", function(done) {
      let services = [];
      hub.consume("a", "^1.0.0", service => services.push(service));

      return onNextTick(done, function() {
        expect(services).to.be.empty;

        hub.provide("a", "1.0.0", {x: 1});
        hub.provide("a", "1.1.0", {y: 2});
        hub.provide("b", "1.0.0", {z: 3});

        return expect(services).to.eql([{x: 1}, {y: 2}]);
      });
    });

    return it("can specify a key path that navigates into the contents of a service", function(done) {
      hub.provide("a", "1.0.0", {
        b: {
          c: 1
        }
      });
      hub.provide("a", "1.0.0", {
        d: {
          e: 2
        }
      });

      let services = [];
      hub.consume("a.b", "^1.0.0", service => services.push(service));

      return onNextTick(done, () => expect(services).to.eql([{c: 1}]));
    });
  });

  it("can specify a key path that's shorter than the key path passed to ::provide", function(done) {
    hub.provide("a.b", "1.0.0", {c: 1})
    hub.provide("a.d", "1.0.0", {e: 2})

    let services = []
    hub.consume("a", "^1.0.0", function(service) { services.push(service) })

    return onNextTick(done, () => expect(services).to.eql([{b: {c: 1}}, {d: {e: 2}}]));

  })

  describe("disposing of a consumer", () =>
    it("does not invoke the consumer callback for any pending or newly-added providers", function(done) {
      let services = [];
      let disposable = hub.consume("a", "^1.0.0", service => services.push(service));

      hub.provide("a", "1.0.0", {x: 1});

      disposable.dispose();

      hub.provide("a", "1.0.1", {y: 2});

      return onNextTick(done, () => expect(services).to.be.empty)
    })
  );

  describe("disposing of a provider", function() {
    it("does not invoke the callbacks of any pending or newly-added consumers", function(done) {
      let disposable1 = hub.provide("a", "1.0.0", {x: 1});
      let disposable2 = hub.provide("a", "1.1.0", {y: 2});

      let services1 = [];
      hub.consume("a", "^1.0.0", service => services1.push(service));

      disposable1.dispose();

      let services2 = [];
      hub.consume("a", "^1.0.0", service => services2.push(service));

      return onNextTick(done, function() {
        expect(services1).to.eql([{y: 2}]);
        return expect(services2).to.eql([{y: 2}]);
      });
    });

    return it("disposes of consumer Disposables", function(done) {
      let provideDisposable = hub.provide("a", "1.0.0", {x: 1});

      let teardownConsumerSpy1 = sinon.spy(function teardownConsumer1() {});
      let teardownConsumerSpy2 = sinon.spy(function teardownConsumer2() {});

      hub.consume("a", "^1.0.0", service => new Disposable(teardownConsumerSpy1));
      hub.consume("a", "^1.0.0", service => new Disposable(teardownConsumerSpy2));

      return onNextTick(done, function() {
        provideDisposable.dispose();

        expect(teardownConsumerSpy1).to.have.been.called
        return expect(teardownConsumerSpy2).to.have.been.called
      });
    });
  });

  return describe("::clear()", () =>
    it("removes all providers and consumers, disposing of consumers' disposables", function(done) {
      hub.provide("a", "1.0.0", {w: 1});
      hub.provide("b", "1.0.0", {x: 2});

      let consumeSpy = sinon.spy(function consume() {});
      let teardownConsumer1Spy = sinon.spy(function teardownConsumer1() {});
      let teardownConsumer2Spy = sinon.spy(function teardownConsumer2() {});

      hub.consume("a", "^1.0.0", service => new Disposable(teardownConsumer1Spy));
      hub.consume("b", "^1.0.0", service => new Disposable(teardownConsumer2Spy));

      onNextTick(() => {}, function() {
        hub.clear();

        expect(teardownConsumer1Spy).to.have.been.called
        return expect(teardownConsumer2Spy).to.have.been.called
      });

      (() => hub.consume("a", "^1.0.0", consumeSpy))();

      return onNextTick(done, () => expect(consumeSpy).not.have.been.called);
    })
  );
});

